---
path: /sdk/features/storing-data
title: Storing data
description: This topic explains which external databases each server-side SDK can use to store flag data.
published: true
tags: ['feature store', 'data', 'sdk']
---

## Overview

This topic explains which external databases each server-side SDK can use to store flag data.

By default, all our SDKs work with an in-memory feature store. This feature store requires no additional configuration. However, data in in-memory feature stores are not persistent. This means when you restart your application, your SDK reloads the entire store's contents.

Persistent feature stores solve this problem by persisting their data so that they can be used across application restarts.

## Using external databases as persistent feature stores

By default, LaunchDarkly's server-side SDKs connect to LaunchDarkly and receive feature flag data, store the flags in local memory, and update them when prompted to by LaunchDarkly. This collection of last known flag data is cached in the "feature store" or "data store."

To learn more, read [Persistent data stores](/sdk/concepts/data-stores).

Alternatively, you can configure an external database to act as a feature store. The SDKs in this topic can use one or more of these three caching options to hold their flag data:

* [Consul](/sdk/features/storing-data/consul)
* [DynamoDB](/sdk/features/storing-data/dynamodb)
* [Redis](/sdk/features/storing-data/redis)

Whichever database you use, there are two ways to use it:

- Exactly like the default configuration, except substituting a [database for the in-memory store while connecting to LaunchDarkly](#using-a-persistent-feature-store-while-still-connecting-to-launchdarkly), or
- Using [_only_ the database as a source of flag data, without connecting to LaunchDarkly](#using-a-persistent-feature-store-without-connecting-to-launchdarkly).

In both configurations, you can control when the SDK checks the database, as opposed to in-memory caching, using the cache time-to-live (TTL) configuration option for your SDK. There is a tradeoff here that will be different for each customer. Most customers find that it's generally unacceptable from a performance standpoint to read from the database on every flag evaluation. If you prefer faster evaluations and can accept some stale data, you can have the SDK check the in-memory caching more frequently. If you prefer fresher data and can accept slower evaluations, you can have the SDK check the database more frequently.

### Using a persistent feature store while still connecting to LaunchDarkly

In this configuration, the SDK receives feature flag data from LaunchDarkly and puts it in the feature store. The only difference is that the store is in a database.

When flags are evaluated, the SDK checks the database to get the latest flag state, usually with some form of in-memory caching. If you have a persistent feature store that has already been populated, the SDK can still evaluate flags using the last known flag state from the store until newer data is available from LaunchDarkly.

To set up this configuration, most people create some kind of object for the specific type of database and put it in the client configuration's feature store property. In PHP, this property is called the "feature requester."

If there are multiple instances of your application configured in this way with the same database, the same data gets written to the database multiple times, because each instance receives feature flags from LaunchDarkly. This is harmless, but it is inefficient, so you may want to use a persistent feature store without connecting to LaunchDarkly, as described below.

### Using a persistent feature store without connecting to LaunchDarkly

This is similar to the previous configuration: When flags are evaluated, the SDK checks the database to get the latest flag state, usually with some form of in-memory caching. However, in this configuration the SDK does not connect to LaunchDarkly at all. Instead, it relies on some other process which _does_ have a LaunchDarkly connection to write the latest flag data to the database, where the SDK will then read it.

The other process could be the Relay Proxy in offline or daemon mode, or any other application that creates an SDK client with the same persistent store. To learn more about the Relay Proxy, read [The Relay Proxy](/home/relay-proxy).

The Relay Proxy is also known as the LaunchDarkly Daemon, so some versions of the SDKs refer to this mode as "LDD mode." Creating the client is the same as above in terms of specifying the persistent store, but you must also add an option to make the SDK _not_ connect to LaunchDarkly.

## Server-side SDKs

This feature is available in the following server-side SDKs:

* [.NET (server-side)](#net-server-side)
* [C/C++ (server-side)](#cc-server-side)
* [Erlang](#erlang)
* [Go](#go)
* [Haskell](#haskell)
* [Java](#java)
* [Lua](#lua)
* [Node.js (server-side)](#nodejs-server-side)
* [PHP](#php)
* [Python](#python)
* [Ruby](#ruby)

### .NET (server-side)

<Details summary="Expand .NET (server-side) code sample">

The .NET SDK can use [Consul](/sdk/features/storing-data/consul#net-server-side), [DynamoDB](/sdk/features/storing-data/dynamodb#net-server-side), or [Redis](/sdk/features/storing-data/redis#net-server-side) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="C#">

```csharp
using LaunchDarkly.Sdk.Server;
using LaunchDarkly.Sdk.Server.Integrations;

var config = Configuration.Builder(sdkKey)
    .DataStore(
        Components.PersistentDataStore(
            SomeDatabaseName.DataStore()
        )
    )
    .Build();
```

</CSTab>
</CodeSample>

To learn more, read [`ConfigurationBuilder.DataStore`](https://launchdarkly.github.io/dotnet-server-sdk/api/LaunchDarkly.Sdk.Server.ConfigurationBuilder.html#DataStore).

To use a persistent feature store without connecting to LaunchDarkly, use the `DataStore` builder method as above, and then use [`Components.ExternalUpdatesOnly`](https://launchdarkly.github.io/dotnet-server-sdk/api/LaunchDarkly.Sdk.Server.Components.html#LaunchDarkly_Sdk_Server_Components_ExternalUpdatesOnly) to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#net-server-side).
</Details>

### C/C++ (server-side)

<Details summary="Expand C/C++ (server-side) code sample">

The C/C++ SDK can use [Redis](/sdk/features/storing-data/redis#cc-server-side) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="C/C++">

```c
#include <launchdarkly/api.h>

struct LDConfig *config = LDConfigNew("sdk-key-123abc");

struct LDStoreInterface *store = ConstructYourFeatureStoreInterface();

LDConfigSetFeatureStoreBackend(config, store);
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, use `LDConfigSetFeatureStoreBackend` as above, and then use [`LDConfigSetUseLDD`](https://launchdarkly.github.io/c-server-sdk/config_8h.html#a1adabf587a063f4a2c97bb5927458963) to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#cc-server-side).
</Details>

### Erlang

<Details summary="Expand Erlang code sample">

The Erlang SDK can use [Redis](/sdk/features/storing-data/redis#erlang) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Erlang">

```erlang
LdOptions = #{
  feature_store => your_feature_store
},
ldclient:start_instance("sdk-key-123abc", LdOptions).
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, set the `feature_store` property as above, and then set the `use_ldd` option to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#erlang).
</Details>

### Go

<Details summary="Expand Go code sample">

The Go SDK can use [Consul](/sdk/features/storing-data/consul#go), [DynamoDB](/sdk/features/storing-data/dynamodb#go), or [Redis](/sdk/features/storing-data/redis#go) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Go SDK v6.0">

```go
import (
    "time"

    ld "github.com/launchdarkly/go-server-sdk/v6"
    "github.com/launchdarkly/go-server-sdk/v6/ldcomponents"
    examplepackage "github.com/launchdarkly/go-server-sdk-some-example-database"
)

var config ld.Config
config.DataStore = ldcomponents.PersistentDataStore(
    examplepackage.DataStore().SomeStoreOptions(),
)
client, _ := ld.MakeCustomClient(sdkKey, config, 5*time.Second)
```

</CSTab>
<CSTab label="Go SDK v5.x">

```go
import (
    "time"

    ld "gopkg.in/launchdarkly/go-server-sdk.v5"
    "gopkg.in/launchdarkly/go-server-sdk.v5/ldcomponents"
    examplepackage "github.com/launchdarkly/go-server-sdk-some-example-database"
)

var config ld.Config
config.DataStore = ldcomponents.PersistentDataStore(
    examplepackage.DataStore().SomeStoreOptions(),
)
client, _ := ld.MakeCustomClient(sdkKey, config, 5*time.Second)
```

</CSTab>
</CodeSample>

To learn more, read [`PersistentDataStore`](https://pkg.go.dev/github.com/launchdarkly/go-server-sdk/v6/ldcomponents#PersistentDataStore).

To use a persistent feature store without connecting to LaunchDarkly, use `PersistentDataStore()` as above, and then use [`ExternalUpdatesOnly()`](https://pkg.go.dev/github.com/launchdarkly/go-server-sdk/v6/ldcomponents#ExternalUpdatesOnly) to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#go).
</Details>

### Haskell

<Details summary="Expand Haskell code sample">

The Haskell SDK can use [Redis](/sdk/features/storing-data/redis#haskell) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Haskell">

```haskell
import LaunchDarkly.Server

main = do
    backend <- makeYourBackendInterface

    let config = configSetStoreBackend backend $ makeConfig "sdk-key-123abc"

    client <- makeClient config
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, use `configSetStoreBackend` as above, and then use `configSetUseLdd` to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#haskell).
</Details>

### Java

<Details summary="Expand Java code sample">

The Java SDK can use [Consul](/sdk/features/storing-data/consul#java), [DynamoDB](/sdk/features/storing-data/dynamodb#java), or [Redis](/sdk/features/storing-data/redis#java) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Java">

```java
import com.launchdarkly.sdk.server.*;
import com.launchdarkly.sdk.server.integrations.*;

LDConfig config = new LDConfig.Builder()
  .dataStore(
    Components.persistentDataStore(
      SomeDatabaseName.dataStore(storeOptions)
    )
  )
  .build();
LDClient client = new LDClient(sdkKey, config);
```

</CSTab>
</CodeSample>

To learn more, read [`Components.persistentDataStore`](https://javadoc.io/doc/com.launchdarkly/launchdarkly-java-server-sdk/latest/com/launchdarkly/sdk/server/Components.html#persistentDataStore(com.launchdarkly.sdk.server.subsystems.ComponentConfigurer)).

To use a persistent feature store without connecting to LaunchDarkly, use `persistentDataStore` as above, and then use [`externalUpdatesOnly`](https://javadoc.io/static/com.launchdarkly/launchdarkly-java-server-sdk/5.0.0/com/launchdarkly/sdk/server/Components.html#externalUpdatesOnly--m) to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#java).
</Details>

### Lua

<Details summary="Expand Lua code sample">

The module `launchdarkly_server_sdk_redis` allows feature flag data to be cached with Redis. To learn more, read [Redis](/sdk/features/storing-data/redis#lua).

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Lua">

```lua
local l = require("launchdarkly_server_sdk")

local backend = makeYourBackendInterface()

local c = l.clientInit({
    key                 = "sdk-key-123abc",
    featureStoreBackend = backend
)}
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, set the `featureStoreBackend` as above, and then set the `useLDD` property to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#lua).
</Details>

### Node.js (server-side)

<Details summary="Expand Node.js (server-side) code sample">

The Node.js SDK can use [Consul](/sdk/features/storing-data/consul#nodejs-server-side), [DynamoDB](/sdk/features/storing-data/dynamodb#nodejs-server-side), or [Redis](/sdk/features/storing-data/redis#nodejs-server-side) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Node.js SDK v8.x (JavaScript)">

```js
const ld = require('@launchdarkly/node-server-sdk');

const store = SomeKindOfFeatureStore(storeOptions);
const options = {
  featureStore: store
};
const client = ld.init('sdk-key-123abc', options);
```

</CSTab>
<CSTab label="Node.js SDK v8.x (TypeScript)">

```ts
import * as ld from '@launchdarkly/node-server-sdk';

const store = SomeKindOfFeatureStore(storeOptions);

const options: ld.LDOptions = {
  featureStore: store,
};
const client = ld.init('sdk-key-123abc', options);
```

</CSTab>
<CSTab label="Node.js SDK v7.x (JavaScript)">

```js
const ld = require('launchdarkly-node-server-sdk');

const store = SomeKindOfFeatureStore(storeOptions);
const options = {
  featureStore: store
};
const client = ld.init('sdk-key-123abc', options);
```

</CSTab>
<CSTab label="Node.js SDK v7.x (TypeScript)">

```ts
import * as ld from 'launchdarkly-node-server-sdk';

const store = SomeKindOfFeatureStore(storeOptions);

const options: ld.LDOptions = {
  featureStore: store,
};
const client = ld.init('sdk-key-123abc', options);
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, set the `featureStore` property as above, and then set the `useLdd` property to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#nodejs-server-side).
</Details>

### PHP

<Details summary="Expand PHP code sample">

The PHP SDK can use [Consul](/sdk/features/storing-data/consul), [DynamoDB](/sdk/features/storing-data/dynamodb), or [Redis](/sdk/features/storing-data/redis) to get flag data.

Unlike other server-side SDKs, the PHP SDK cannot connect to LaunchDarkly while using a database as a backing store. It can only read from a database that has been populated by the [Relay Proxy](/home/relay-proxy), or by another application that uses a server-side LaunchDarkly SDK. To learn more, read [Using daemon mode](/home/relay-proxy/using#using-daemon-mode).

Another difference from other SDKs is that the PHP SDK does not have an in-memory cache for database queries. This is because in PHP, the entire in-memory application state is normally discarded after each request. Therefore, code examples for PHP do not include a cache TTL parameter.

To read from a persistent feature store without connecting to LaunchDarkly:

<CodeSample>
<CSTab label="PHP">

```php
$client = new LaunchDarkly\LDClient("sdk-key-123abc", [
    'feature_requester' => LaunchDarkly\Integrations\NameOfDatabase::featureRequester()
]);
```

</CSTab>
</CodeSample>

Prior to version 4.0, the database integrations were included in the main PHP SDK package. Starting in version 4.0, they are in separate packages.
</Details>

### Python

<Details summary="Expand Python code sample">

The Python SDK can use [Consul](/sdk/features/storing-data/consul), [DynamoDB](/sdk/features/storing-data/dynamodb), or [Redis](/sdk/features/storing-data/redis) to hold flag data.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Python">

```python
import ldclient
from ldclient.config import Config

store = SomeKindOfFeatureStore(store_options)
config = Config(feature_store=store)
ldclient.set_config(config)
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, set the `feature_store` property as above, and then set the `use_ldd` property to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#python).
</Details>

### Ruby

<Details summary="Expand Ruby code sample">

The Ruby SDK can use [Consul](/sdk/features/storing-data/consul), [DynamoDB](/sdk/features/storing-data/dynamodb), or [Redis](/sdk/features/storing-data/redis) to hold flag data.

These adapters are implemented in the `LaunchDarkly::Integrations::Redis`, `LaunchDarkly::Integrations::DynamoDB`, and `LaunchDarkly::Integrations::Consul` modules. To use them, call the `new_feature_store` method in the module, and put the returned object in the `feature_store` property of your client configuration.

To use a persistent feature store while connecting to LaunchDarkly:

<CodeSample>
<CSTab label="Ruby">

```ruby
require 'ldclient-rb'

store = SomeKindOfFeatureStore.new(storeOptions)
config = LaunchDarkly::Config.new(
  feature_store: store
)
client = LaunchDarkly::Client.new(sdk_key, config)
```

</CSTab>
</CodeSample>

To use a persistent feature store without connecting to LaunchDarkly, set the `feature_store` property as above, and then set the `use_ldd` property to configure daemon mode. To learn more, read [Using daemon mode](/sdk/features/relay-proxy-configuration/daemon-mode#ruby).
</Details>
