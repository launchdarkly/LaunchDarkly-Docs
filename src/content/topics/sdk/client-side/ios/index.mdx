---
path: /sdk/client-side/ios
title: iOS SDK reference
description: This topic documents how to get started with the iOS SDK, and links to reference information on all of the supported features.
tags: ['ios', 'sdk', 'client-side']
published: true
---

<Callout intent="info">
<CalloutTitle>Version 8 of the iOS SDK replaces users with contexts</CalloutTitle>
<CalloutDescription>

A context is a generalized way of referring to the people, services, machines, or other resources that encounter feature flags in your product. Contexts replace another data object in LaunchDarkly: "users."

Code samples on this page are from the two most recent SDK versions where they differ. To learn more about upgrading, read the iOS SDK 7.x to 8.0 migration guides for [Swift](/sdk/client-side/ios/migration-7-to-8-swift) or [Objective-C](/sdk/client-side/ios/migration-7-to-8-objc) and [Best practices for upgrading users to contexts](/guides/flags/upgrading-contexts).

</CalloutDescription>
</Callout>

## Overview

This topic documents how to get started with the iOS SDK, and links to reference information on all of the supported features.

<Callout intent="primary">
<CalloutTitle>SDK quick links</CalloutTitle>
<CalloutDescription>

LaunchDarkly's SDKs are open source. In addition to this reference guide, we provide source, API reference documentation, and sample applications:

<Table>
  <TableHeader>
    <TableHeadCell>Resource</TableHeadCell>
    <TableHeadCell>Location</TableHeadCell>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableCell>SDK API documentation</TableCell>
      <TableCell>[SDK API docs](https://launchdarkly.github.io/ios-client-sdk/)</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>GitHub repository</TableCell>
      <TableCell>[ios-client-sdk](https://github.com/launchdarkly/ios-client-sdk/tree/v8)</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>Sample applications</TableCell>
      <TableCell>[iOS (Objective-C)](https://github.com/launchdarkly/hello-ios)<br/> [iOS (Swift)](https://github.com/launchdarkly/hello-ios-swift) <br/>[macOS](https://github.com/launchdarkly/hello-macos)<br/>[tvOS](https://github.com/launchdarkly/hello-tvos)</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>Published module</TableCell>
      <TableCell>[CocoaPods](https://cocoapods.org/pods/LaunchDarkly)</TableCell>
    </TableRow>
  </TableBody>
</Table>

</CalloutDescription>
</Callout>

<Callout intent="info">
<CalloutTitle>SDK version compatibility</CalloutTitle>
<CalloutDescription>

The LaunchDarkly iOS SDK, version 4.0.0 and higher, is compatible with applications written in either Swift or Objective-C. The inline code samples include both languages. The SDK is written in Swift.

</CalloutDescription>
</Callout>

## Getting started

After you complete the [Getting started](/home/getting-started) process, follow these instructions to start using the LaunchDarkly SDK in your application.

### Including the SDK as a dependency

The first step is to install the LaunchDarkly SDK as a dependency in your application.

LaunchDarkly supports multiple methods for installing the SDK:
- [Using the Swift Package Manager](#using-the-swift-package-manager)
- [Using CocoaPods](#using-cocoapods)
- [Using Carthage](#using-carthage)
- [Installing the SDK manually](#installing-the-sdk-manually)

Each method is explained below.

#### Using the Swift Package Manager
---
<br/>

If you use the [Swift Package Manager](https://swift.org/package-manager/), you can install the SDK through Xcode or include it as a dependency in your `Package.swift` file.

To add a package dependency to your Xcode project, select "File," "Swift Packages," "Add Package Dependency" and enter the [iOS SDK repository URL](https://github.com/launchdarkly/ios-client-sdk) clone URL, then select your desired version constraints.

Including the SDK as a dependency in a `Package.swift` file looks like this:

<CodeSample>
<CSTab label="Package.swift">

```swift
//...
    dependencies: [
        .package(url: "https://github.com/launchdarkly/ios-client-sdk.git", .upToNextMinor("8.0.0")),
    ],
    targets: [
        .target(
            name: "YOUR_TARGET",
            dependencies: ["LaunchDarkly"]
        )
    ],
//...
```
</CSTab>
</CodeSample>

#### Using CocoaPods
---
<br/>

If you use [CocoaPods](https://cocoapods.org/), you can install the SDK by adding the following to your `Podfile`. To identify the latest version, read the [SDK releases page](https://github.com/launchdarkly/ios-client-sdk/releases).

Here is the code to add to your `Podfile`:

<CodeSample>
<CSTab label="Podfile">

```ruby
use_frameworks!
target 'YourTargetName' do
  pod 'LaunchDarkly', '~> 8.0'
end
```

</CSTab>
</CodeSample>

#### Using Carthage
---
<br/>

If you use [Carthage](https://github.com/Carthage/Carthage), you can install the SDK by specifying it in your `Cartfile`. To identify the latest version, read the [SDK releases page](https://github.com/launchdarkly/ios-client-sdk/releases).

Here is the code to include in your `Cartfile`:

<CodeSample>
<CSTab label="Cartfile">

```swift
github "launchdarkly/ios-client" ~> 8.0
```

</CSTab>
</CodeSample>

#### Installing the SDK manually
---
<br/>

For instructions on installing the SDK without CocoaPods or Carthage, read the [SDK readme](https://github.com/launchdarkly/ios-client-sdk/blob/master/README.md).

### Using the SDK in your application

This is a brief overview of using the SDK. Read the detailed sections below for more information on configuration and advanced features.

#### Importing
---
<br/>

First import the LaunchDarkly client in your application code:

<CodeSample>
<CSTab label="Swift">

```swift
import LaunchDarkly
```

</CSTab>
<CSTab label="Objective-C">

```objectivec
@import LaunchDarkly;
```

</CSTab>
</CodeSample>

#### Initializing the SDK
---
<br/>

After importing the SDK, configure and initialize it. Specify your mobile key when configuring the SDK so that your application is authorized to connect to a particular environment within LaunchDarkly. Your mobile key is available in the Projects tab of your [Account settings page](https://app.launchdarkly.com/settings/projects).

<Callout intent="alert">
<CalloutTitle>Never embed a server-side SDK key into a client-side application</CalloutTitle>
<CalloutDescription>

Mobile keys are not secret and you can expose them in your client-side code without risk. However, never embed a server-side SDK key into a client-side application.

</CalloutDescription>
</Callout>

Here is how to specify your mobile key:

<CodeSample>
<CSTab label="iOS SDK v8.0 (Swift)">

```swift
// If you would like the completion to be called even in cases where
// the SDK is unable to retrieve flags for the context, there is a variant
// to the start method that takes a maximum time to wait for flag values.
// This variant notifies the completion whether the operation timed out.
let config = LDConfig(mobileKey: "mobile-key-123abc")
let context = LDContextBuilder(key: "context-key-123abc")
LDClient.start(config: config, context: context, startWaitSeconds: 5) { timedOut in
    if timedOut {
        // The SDK may not have the most recent flags for the configured context
    } else {
        // The SDK has received flags for the configured context
    }
}
```

</CSTab>
<CSTab label="iOS SDK v8.0 (Objective-C)">

```objectivec
LDConfig *config = [[LDConfig alloc] initWithMobileKey:@"mobile-key-123abc"];
LDContext *context = [[LDContext alloc] initWithKey:@"context-key-123abc"];

[LDClient startWithConfiguration:config context:context startWaitSeconds:5.0 completion:^(bool timedOut) {
    if(timedOut) {
        // The SDK may not have the most recent flags for the configured context
    } else {
        // The SDK has received flags for the configured context
    }
}];
```

</CSTab>
<CSTab label="iOS SDK v7.x (Swift)">

```swift
// If you would like the completion to be called even in cases where
// the SDK is unable to retrieve flags for the context, there is a variant
// to the start method that takes a maximum time to wait for flag values.
// This variant notifies the completion whether the operation timed out.
let config = LDConfig(mobileKey: "mobile-key-123abc")
let user = LDUser(key: "user-key-123abc")
LDClient.start(config: config, user: user, startWaitSeconds: 5) { timedOut in
    if timedOut {
        // The SDK may not have the most recent flags for the configured user
    } else {
        // The SDK has received flags for the configured user
    }
}
```

</CSTab>
<CSTab label="iOS SDK v7.x (Objective-C)">

```objectivec
LDConfig *config = [[LDConfig alloc] initWithMobileKey:@"mobile-key-123abc"];
LDUser *user = [[LDUser alloc] initWithKey:@"user-key-123abc"];

[LDClient startWithConfiguration:config user:user startWaitSeconds:5.0 completion:^(bool timedOut) {
    if(timedOut) {
        // The SDK may not have the most recent flags for the configured context
    } else {
        // The SDK has received flags for the configured context
    }
}];
```

</CSTab>
</CodeSample>

However, calling blocking code from the main thread in a mobile app is not considered a best practice. The preferred method is loading the client asynchronously.

Here's how:

<CodeSample>
<CSTab label="iOS SDK v8.0 (Swift)">

```swift
let config = LDConfig(mobileKey: "mobile-key-123abc")
let context = LDContextBuilder(key: "context-key-123abc")

LDClient.start(config: config, context: context)

// If you need to ensure that the most recent flags have been received
// start supports an optional completion that is triggered when the SDK
// has retrieved flags for the configured context.
LDClient.start(config: config, context: context) {
    // Client has received flags for the context
}
```

</CSTab>
<CSTab label="iOS SDK v8.0 (Objective-C)">

```objectivec
[LDClient startWithConfiguration:config context:context startWaitSeconds:5.0 completion:^(bool timedOut) {
    if(timedOut) {
        // The SDK may not have the most recent flags for the configured context
    } else {
        // The SDK has received flags for the configured context
    }
}];
```

</CSTab>
<CSTab label="iOS SDK v7.x (Swift)">

```swift
let config = LDConfig(mobileKey: "mobile-key-123abc")
let user = LDUser(key: "context-key-123abc")

LDClient.start(config: config, user: user)

// If you need to ensure that the most recent flags have been received
// start supports an optional completion that is triggered when the SDK
// has retrieved flags for the configured user.
LDClient.start(config: config, user: user) {
    // Client has received flags for the user
}
```

</CSTab>
<CSTab label="iOS SDK v7.x (Objective-C)">

```objectivec
[LDClient startWithConfiguration:config user:user startWaitSeconds:5.0 completion:^(bool timedOut) {
    if(timedOut) {
        // The SDK may not have the most recent flags for the configured user
    } else {
        // The SDK has received flags for the configured user
    }
}];
```

</CSTab>
</CodeSample>

<Callout intent="alert">
<CalloutTitle>LDClient must be a singleton</CalloutTitle>
<CalloutDescription>

It's important to make `LDClient` a singleton for each LaunchDarkly project. The client instance maintains internal state that allows LaunchDarkly to serve feature flags without making any remote requests. Do not instantiate a new client with every request.

If you have multiple LaunchDarkly projects, you should use the multiple environments feature. To learn more, read [Multiple environments](/sdk/features/multiple-environments#ios).

</CalloutDescription>
</Callout>

#### Retrieving the client instance
---
<br/>

After calling `start`, you can retrieve the `LDClient` instance with the static method `LDClient.get()`:

<CodeSample>
<CSTab label="Swift">

```swift
let client = LDClient.get()!
```

</CSTab>
<CSTab label="Objective-C">

```objectivec
LDClient *client = [LDClient get];
```

</CSTab>
</CodeSample>

#### Getting the variation to serve the configured context
---

<br/>
<Callout intent="alert">
<CalloutTitle>Making feature flags available to this SDK</CalloutTitle>
<CalloutDescription>

You must make feature flags available to mobile SDKs before the SDK can evaluate those flags. If an SDK tries to evaluate a feature flag that is not available, the context will receive the fallback value for that flag.

To make a flag available to this SDK, check the **SDKs using Mobile key** checkbox during flag creation, or on the flag's Settings tab. To make all of a project's flags available to this SDK by default, check the **SDKs using Mobile key** checkbox in your project [Settings](https://app.launchdarkly.com/settings/projects).

</CalloutDescription>
</Callout>

You can use `client` to check which variation a particular context will receive for a given feature flag.

Here's how:

<CodeSample>
<CSTab label="Swift">

```swift
let showFeature = client.boolVariation(forKey: "flag-key-123abc", defaultValue: false)

if showFeature {
  // Application code to show the feature
else {
  // The code to run if the feature is off
}
```

</CSTab>
<CSTab label="Objective-C">

```objectivec
BOOL showFeature = [client boolVariationForKey:@"flag-key-123abc" defaultValue:NO];
if (showFeature) {
    // Application code to show the feature
} else {
    // The code to run if the feature is off
}
```

</CSTab>
</CodeSample>

## Background fetch

When the app is backgrounded, the SDK does not receive real-time events. 

Unlike other mobile SDKs, the iOS SDK does not support background fetch, so devices on the iOS operating system will not fetch flags from the background. However, devices on MacOS will update flag values opportunistically, according to the iOS SDK standard background polling defaults. 

To change the background polling default for flags in your app, add the following code in your `LDConfig`:

<CodeSample>
<CSTab label="Swift">

```swift
var ldConfig = LDConfig(mobileKey: "mobile-key-123abc")
ldConfig.backgroundFlagPollingInterval = 3600
```

</CSTab>
<CSTab label="Objective-C">

```objectivec
LDConfig *config = [[LDConfig alloc] initWithMobileKey:@"mobile-key-123abc"];
config.backgroundFlagPollingInterval = 3600
```

</CSTab>
</CodeSample>

## Shutting down

Shut down the client when your application terminates. To learn more, read [Shutting down](/sdk/features/shutdown#ios).

## Data collection

The data collected by the iOS SDK persists until the number of cached contexts exceeds a limit. When you call `identify`, the number of cached contexts increments. Eventually, the number of cached contexts exceeds `maxCachedContexts`. When that happens, the SDK deletes context data in excess of `maxCachedContext`, starting with the oldest context first.

To learn more about data collection within this SDK and implications on submissions to the Apple App Store, read the [Apple App Store data collection policy](/sdk/concepts/apple-app-store).

## Supported features

This SDK supports the following features:

* [Anonymous contexts and users](/sdk/features/anonymous#ios)
* [Configuration](/sdk/features/config#ios)
* [Evaluating flags](/sdk/features/evaluating#ios)
* [Flag evaluation reasons](/sdk/features/evaluation-reasons#ios)
* [Flushing events](/sdk/features/flush#ios)
* [Getting all flags](/sdk/features/all-flags#ios)
* [Identifying and changing contexts](/sdk/features/identify#ios)
* [Monitoring SDK status](/sdk/features/monitoring#ios)
* [Multiple environments](/sdk/features/multiple-environments#ios)
* [Offline mode](/sdk/features/offline-mode#ios)
* [Private attributes](/sdk/features/private-attributes#ios)
* [Relay Proxy configuration, using proxy mode](/sdk/features/relay-proxy-configuration/proxy-mode#ios)
* [Sending custom events](/sdk/features/events#ios)
* [Service endpoint configuration](/sdk/features/service-endpoint-configuration#ios)
* [Shutting down](/sdk/features/shutdown#ios)
* [Subscribing to flag changes](/sdk/features/flag-changes#ios)
* [User and context configuration](/sdk/features/user-context-config#ios)
